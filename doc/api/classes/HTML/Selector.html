<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>: HTML::Selector [Rails Framework Documentation]</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../rdoc-style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>Class</span>
          HTML::Selector
        </h1>
        <ol class='paths'>
          <li>
            <a href="../../files/vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector_rb.html">vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb</a>
          </li>
        </ol>
        <div class='parent'>
          Parent:
          <strong><a href="../Object.html">Object</a></strong>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            <p>
            Selects HTML elements using CSS 2 selectors.
            </p>
            <p>
            The <tt>Selector</tt> class uses CSS selector expressions to match and
            select HTML elements.
            </p>
            <p>
            For example:
            </p>
            <pre>selector = HTML::Selector.new &quot;form.login[action=/login]&quot;</pre>
            <p>
            creates a new selector that matches any <tt>form</tt> element with the
            class <tt>login</tt> and an attribute <tt>action</tt> with the value
            <tt>/login</tt>.
            </p>
            <h3>Matching Elements</h3>
            <p>
            Use the <a href="Selector.html#M000345">match</a> method to determine if an
            element matches the selector.
            </p>
            <p>
            For simple selectors, the method returns an array with that element, or
            <tt>nil</tt> if the element does not match. For complex selectors (see
            below) the method returns an array with all matched elements, of
            <tt>nil</tt> if no match found.
            </p>
            <p>
            For example:
            </p>
            <pre>if selector.match(element)&#x000A;  puts &quot;Element is a login form&quot;&#x000A;end</pre>
            <h3>Selecting Elements</h3>
            <p>
            Use the <a href="Selector.html#M000346">select</a> method to select all
            matching elements starting with one element and going through all children
            in depth-first order.
            </p>
            <p>
            This method returns an array of all matching elements, an empty array if no
            match is found
            </p>
            <p>
            For example:
            </p>
            <pre>selector = HTML::Selector.new &quot;input[type=text]&quot;&#x000A;matches = selector.select(element)&#x000A;matches.each do |match|&#x000A;  puts &quot;Found text field with name #{match.attributes['name']}&quot;&#x000A;end</pre>
            <h3>Expressions</h3>
            <p>
            Selectors can match elements using any of the following criteria:
            </p>
            <ul>
            <li><tt>name</tt> &#8212; Match an element based on its name (tag name). For
            example, <tt>p</tt> to match a paragraph. You can use <tt>*</tt> to match
            any element.
            
            </li>
            <li><tt>#id</tt> &#8212; Match an element based on its identifier (the
            <tt>id</tt> attribute). For example, <tt>#page</tt>.
            
            </li>
            <li><tt>.class</tt> &#8212; Match an element based on its class name, all class
            names if more than one specified.
            
            </li>
            <li><tt>[attr]</tt> &#8212; Match an element that has the specified attribute.
            
            </li>
            <li><tt>[attr=value]</tt> &#8212; Match an element that has the specified
            attribute and value. (More operators are supported see below)
            
            </li>
            <li><tt>:pseudo-class</tt> &#8212; Match an element based on a pseudo class,
            such as <tt>:nth-child</tt> and <tt>:empty</tt>.
            
            </li>
            <li><tt>:not(expr)</tt> &#8212; Match an element that does not match the
            negation expression.
            
            </li>
            </ul>
            <p>
            When using a combination of the above, the element name comes first
            followed by identifier, class names, attributes, pseudo classes and
            negation in any order. Do not separate these parts with spaces! Space
            separation is used for descendant selectors.
            </p>
            <p>
            For example:
            </p>
            <pre>selector = HTML::Selector.new &quot;form.login[action=/login]&quot;</pre>
            <p>
            The matched element must be of type <tt>form</tt> and have the class
            <tt>login</tt>. It may have other classes, but the class <tt>login</tt> is
            required to match. It must also have an attribute called <tt>action</tt>
            with the value <tt>/login</tt>.
            </p>
            <p>
            This selector will match the following element:
            </p>
            <pre>&lt;form class=&quot;login form&quot; method=&quot;post&quot; action=&quot;/login&quot;&gt;</pre>
            <p>
            but will not match the element:
            </p>
            <pre>&lt;form method=&quot;post&quot; action=&quot;/logout&quot;&gt;</pre>
            <h3>Attribute Values</h3>
            <p>
            Several operators are supported for matching attributes:
            </p>
            <ul>
            <li><tt>name</tt> &#8212; The element must have an attribute with that name.
            
            </li>
            <li><tt>name=value</tt> &#8212; The element must have an attribute with that
            name and value.
            
            </li>
            <li><tt>name^=value</tt> &#8212; The attribute value must start with the
            specified value.
            
            </li>
            <li><tt>name$=value</tt> &#8212; The attribute value must end with the
            specified value.
            
            </li>
            <li><tt>name*=value</tt> &#8212; The attribute value must contain the specified
            value.
            
            </li>
            <li><tt>name~=word</tt> &#8212; The attribute value must contain the specified
            word (space separated).
            
            </li>
            <li><tt>name|=word</tt> &#8212; The attribute value must start with specified
            word.
            
            </li>
            </ul>
            <p>
            For example, the following two selectors match the same element:
            </p>
            <pre>#my_id&#x000A;[id=my_id]</pre>
            <p>
            and so do the following two selectors:
            </p>
            <pre>.my_class&#x000A;[class~=my_class]</pre>
            <h3>Alternatives, siblings, children</h3>
            <p>
            Complex selectors use a combination of expressions to match elements:
            </p>
            <ul>
            <li><tt>expr1 expr2</tt> &#8212; Match any element against the second
            expression if it has some parent element that matches the first expression.
            
            </li>
            <li><tt>expr1 &gt; expr2</tt> &#8212; Match any element against the second
            expression if it is the child of an element that matches the first
            expression.
            
            </li>
            <li><tt>expr1 + expr2</tt> &#8212; Match any element against the second
            expression if it immediately follows an element that matches the first
            expression.
            
            </li>
            <li><tt>expr1 ~ expr2</tt> &#8212; Match any element against the second
            expression that comes after an element that matches the first expression.
            
            </li>
            <li><tt>expr1, expr2</tt> &#8212; Match any element against the first
            expression, or against the second expression.
            
            </li>
            </ul>
            <p>
            Since children and sibling selectors may match more than one element given
            the first element, the <a href="Selector.html#M000345">match</a> method may
            return more than one match.
            </p>
            <h3>Pseudo classes</h3>
            <p>
            Pseudo classes were introduced in CSS 3. They are most often used to select
            elements in a given position:
            </p>
            <ul>
            <li><tt>:root</tt> &#8212; Match the element only if it is the root element (no
            parent element).
            
            </li>
            <li><tt>:empty</tt> &#8212; Match the element only if it has no child elements,
            and no text content.
            
            </li>
            <li><tt>:only-child</tt> &#8212; Match the element if it is the only child
            (element) of its parent element.
            
            </li>
            <li><tt>:only-of-type</tt> &#8212; Match the element if it is the only child
            (element) of its parent element and its type.
            
            </li>
            <li><tt>:first-child</tt> &#8212; Match the element if it is the first child
            (element) of its parent element.
            
            </li>
            <li><tt>:first-of-type</tt> &#8212; Match the element if it is the first child
            (element) of its parent element of its type.
            
            </li>
            <li><tt>:last-child</tt> &#8212; Match the element if it is the last child
            (element) of its parent element.
            
            </li>
            <li><tt>:last-of-type</tt> &#8212; Match the element if it is the last child
            (element) of its parent element of its type.
            
            </li>
            <li><tt>:nth-child(b)</tt> &#8212; Match the element if it is the b-th child
            (element) of its parent element. The value <tt>b</tt> specifies its index,
            starting with 1.
            
            </li>
            <li><tt>:nth-child(an+b)</tt> &#8212; Match the element if it is the b-th child
            (element) in each group of <tt>a</tt> child elements of its parent element.
            
            </li>
            <li><tt>:nth-child(-an+b)</tt> &#8212; Match the element if it is the first
            child (element) in each group of <tt>a</tt> child elements, up to the first
            <tt>b</tt> child elements of its parent element.
            
            </li>
            <li><tt>:nth-child(odd)</tt> &#8212; Match element in the odd position (i.e.
            first, third). Same as <tt>:nth-child(2n+1)</tt>.
            
            </li>
            <li><tt>:nth-child(even)</tt> &#8212; Match element in the even position (i.e.
            second, fourth). Same as <tt>:nth-child(2n+2)</tt>.
            
            </li>
            <li><tt>:nth-of-type(..)</tt> &#8212; As above, but only counts elements of its
            type.
            
            </li>
            <li><tt>:nth-last-child(..)</tt> &#8212; As above, but counts from the last
            child.
            
            </li>
            <li><tt>:nth-last-of-type(..)</tt> &#8212; As above, but counts from the last
            child and only elements of its type.
            
            </li>
            <li><tt>:not(selector)</tt> &#8212; Match the element only if the element does
            not match the simple selector.
            
            </li>
            </ul>
            <p>
            As you can see, <tt>:nth-child<tt> pseudo class and its variant can get
            quite tricky and the CSS specification doesn&#8217;t do a much better job
            explaining it. But after reading the examples and trying a few
            combinations, it&#8217;s easy to figure out.
            </p>
            <p>
            For example:
            </p>
            <pre>table tr:nth-child(odd)</pre>
            <p>
            Selects every second row in the table starting with the first one.
            </p>
            <pre>div p:nth-child(4)</pre>
            <p>
            Selects the fourth paragraph in the <tt>div</tt>, but not if the
            <tt>div</tt> contains other elements, since those are also counted.
            </p>
            <pre>div p:nth-of-type(4)</pre>
            <p>
            Selects the fourth paragraph in the <tt>div</tt>, counting only paragraphs,
            and ignoring all other elements.
            </p>
            <pre>div p:nth-of-type(-n+4)</pre>
            <p>
            Selects the first four paragraphs, ignoring all others.
            </p>
            <p>
            And you can always select an element that matches one set of rules but not
            another using <tt>:not</tt>. For example:
            </p>
            <pre>p:not(.post)</pre>
            <p>
            Matches all paragraphs that do not have the class <tt>.post</tt>.
            </p>
            <h3>Substitution Values</h3>
            <p>
            You can use substitution with identifiers, class names and element values.
            A substitution takes the form of a question mark (<tt>?</tt>) and uses the
            next value in the argument list following the CSS expression.
            </p>
            <p>
            The substitution value may be a string or a regular expression. All other
            values are converted to strings.
            </p>
            <p>
            For example:
            </p>
            <pre>selector = HTML::Selector.new &quot;#?&quot;, /^\d+$/</pre>
            <p>
            matches any element whose identifier consists of one or more digits.
            </p>
            <p>
            See <a
            href="http://www.w3.org/TR/css3-selectors">www.w3.org/TR/css3-selectors</a>/
            </p>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>public class</h3>
            <ol>
              <li><a href="#M000342">for_class</a></li>
              <li><a href="#M000343">for_id</a></li>
              <li><a href="#M000344">new</a></li>
            </ol>
            <h3>public instance</h3>
            <ol>
              <li><a href="#M000345">match</a></li>
              <li><a href="#M000348">next_element</a></li>
              <li><a href="#M000346">select</a></li>
              <li><a href="#M000347">select_first</a></li>
            </ol>
            <h3>protected instance</h3>
            <ol>
              <li><a href="#M000350">attribute_match</a></li>
              <li><a href="#M000353">next_selector</a></li>
              <li><a href="#M000351">nth_child</a></li>
              <li><a href="#M000352">only_child</a></li>
              <li><a href="#M000349">simple_selector</a></li>
            </ol>
          </div>
          <div id='section'>
            <div id='methods'>
              <h2>Public class methods</h2>
              <div class='method public-class' id='method-M000342'>
                <a name='M000342'></a>
                <div class='synopsis'>
                  <span class='name'>Selector.for_class(cls) => selector<br /></span>
                </div>
                <div class='description'>
                  <p>
                  Creates a new selector for the given class name.
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000342-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000342-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 214</span>&#x000A;214:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">for_class</span>(<span class="ruby-identifier">cls</span>)&#x000A;215:         <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value str">&quot;.?&quot;</span>, <span class="ruby-identifier">cls</span>])&#x000A;216:       <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='method public-class' id='method-M000343'>
                <a name='M000343'></a>
                <div class='synopsis'>
                  <span class='name'>Selector.for_id(id) => selector<br /></span>
                </div>
                <div class='description'>
                  <p>
                  Creates a new selector for the given id.
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000343-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000343-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 223</span>&#x000A;223:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">for_id</span>(<span class="ruby-identifier">id</span>)&#x000A;224:         <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value str">&quot;#?&quot;</span>, <span class="ruby-identifier">id</span>])&#x000A;225:       <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='method public-class' id='method-M000344'>
                <a name='M000344'></a>
                <div class='synopsis'>
                  <span class='name'>Selector.new(string, [values ...]) => selector<br /></span>
                </div>
                <div class='description'>
                  <p>
                  Creates a new selector from a CSS 2 selector expression.
                  </p>
                  <p>
                  The first argument is the selector expression. All other arguments are used
                  for value substitution.
                  </p>
                  <p>
                  Throws InvalidSelectorError is the selector expression is invalid.
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000344-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000344-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 239</span>&#x000A;239:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">selector</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">values</span>)&#x000A;240:       <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-value str">&quot;CSS expression cannot be empty&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">empty?</span>&#x000A;241:       <span class="ruby-ivar">@source</span> = <span class="ruby-value str">&quot;&quot;</span>&#x000A;242:       <span class="ruby-identifier">values</span> = <span class="ruby-identifier">values</span>[<span class="ruby-value">0</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">values</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)&#x000A;243: &#x000A;244:       <span class="ruby-comment cmt"># We need a copy to determine if we failed to parse, and also</span>&#x000A;245:       <span class="ruby-comment cmt"># preserve the original pass by-ref statement.</span>&#x000A;246:       <span class="ruby-identifier">statement</span> = <span class="ruby-identifier">selector</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">dup</span>&#x000A;247: &#x000A;248:       <span class="ruby-comment cmt"># Create a simple selector, along with negation.</span>&#x000A;249:       <span class="ruby-identifier">simple_selector</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>).<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-node">&quot;@#{name}&quot;</span>, <span class="ruby-identifier">value</span>) }&#x000A;250: &#x000A;251:       <span class="ruby-ivar">@alternates</span> = []&#x000A;252:       <span class="ruby-ivar">@depends</span> = <span class="ruby-keyword kw">nil</span>&#x000A;253: &#x000A;254:       <span class="ruby-comment cmt"># Alternative selector.</span>&#x000A;255:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^\s*,\s*/</span>, <span class="ruby-value str">&quot;&quot;</span>)&#x000A;256:         <span class="ruby-identifier">second</span> = <span class="ruby-constant">Selector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>)&#x000A;257:         <span class="ruby-ivar">@alternates</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">second</span>&#x000A;258:         <span class="ruby-comment cmt"># If there are alternate selectors, we group them in the top selector.</span>&#x000A;259:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">alternates</span> = <span class="ruby-identifier">second</span>.<span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-identifier">:@alternates</span>)&#x000A;260:           <span class="ruby-identifier">second</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-identifier">:@alternates</span>, [])&#x000A;261:           <span class="ruby-ivar">@alternates</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">alternates</span>&#x000A;262:         <span class="ruby-keyword kw">end</span>&#x000A;263:         <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot; , &quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">second</span>.<span class="ruby-identifier">to_s</span>&#x000A;264:       <span class="ruby-comment cmt"># Sibling selector: create a dependency into second selector that will</span>&#x000A;265:       <span class="ruby-comment cmt"># match element immediately following this one.</span>&#x000A;266:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^\s*\+\s*/</span>, <span class="ruby-value str">&quot;&quot;</span>)&#x000A;267:         <span class="ruby-identifier">second</span> = <span class="ruby-identifier">next_selector</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>)&#x000A;268:         <span class="ruby-ivar">@depends</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span>, <span class="ruby-identifier">first</span><span class="ruby-operator">|</span>&#x000A;269:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">element</span> = <span class="ruby-identifier">next_element</span>(<span class="ruby-identifier">element</span>)&#x000A;270:             <span class="ruby-identifier">second</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">first</span>)&#x000A;271:           <span class="ruby-keyword kw">end</span>&#x000A;272:         <span class="ruby-keyword kw">end</span>&#x000A;273:         <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot; + &quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">second</span>.<span class="ruby-identifier">to_s</span>&#x000A;274:       <span class="ruby-comment cmt"># Adjacent selector: create a dependency into second selector that will</span>&#x000A;275:       <span class="ruby-comment cmt"># match all elements following this one.</span>&#x000A;276:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^\s*~\s*/</span>, <span class="ruby-value str">&quot;&quot;</span>)&#x000A;277:         <span class="ruby-identifier">second</span> = <span class="ruby-identifier">next_selector</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>)&#x000A;278:         <span class="ruby-ivar">@depends</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span>, <span class="ruby-identifier">first</span><span class="ruby-operator">|</span>&#x000A;279:           <span class="ruby-identifier">matches</span> = []&#x000A;280:           <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">element</span> = <span class="ruby-identifier">next_element</span>(<span class="ruby-identifier">element</span>)&#x000A;281:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">subset</span> = <span class="ruby-identifier">second</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">first</span>)&#x000A;282:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">first</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">subset</span>.<span class="ruby-identifier">empty?</span>&#x000A;283:                 <span class="ruby-identifier">matches</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">subset</span>.<span class="ruby-identifier">first</span>&#x000A;284:                 <span class="ruby-keyword kw">break</span>&#x000A;285:               <span class="ruby-keyword kw">else</span>&#x000A;286:                 <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">subset</span>&#x000A;287:               <span class="ruby-keyword kw">end</span>&#x000A;288:             <span class="ruby-keyword kw">end</span>&#x000A;289:           <span class="ruby-keyword kw">end</span>&#x000A;290:           <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">matches</span>&#x000A;291:         <span class="ruby-keyword kw">end</span>&#x000A;292:         <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot; ~ &quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">second</span>.<span class="ruby-identifier">to_s</span>&#x000A;293:       <span class="ruby-comment cmt"># Child selector: create a dependency into second selector that will</span>&#x000A;294:       <span class="ruby-comment cmt"># match a child element of this one.</span>&#x000A;295:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^\s*&gt;\s*/</span>, <span class="ruby-value str">&quot;&quot;</span>)&#x000A;296:         <span class="ruby-identifier">second</span> = <span class="ruby-identifier">next_selector</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>)&#x000A;297:         <span class="ruby-ivar">@depends</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span>, <span class="ruby-identifier">first</span><span class="ruby-operator">|</span>&#x000A;298:           <span class="ruby-identifier">matches</span> = []&#x000A;299:           <span class="ruby-identifier">element</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">child</span><span class="ruby-operator">|</span>&#x000A;300:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">tag?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">subset</span> = <span class="ruby-identifier">second</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">child</span>, <span class="ruby-identifier">first</span>)&#x000A;301:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">first</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">subset</span>.<span class="ruby-identifier">empty?</span>&#x000A;302:                 <span class="ruby-identifier">matches</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">subset</span>.<span class="ruby-identifier">first</span>&#x000A;303:                 <span class="ruby-keyword kw">break</span>&#x000A;304:               <span class="ruby-keyword kw">else</span>&#x000A;305:                 <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">subset</span>&#x000A;306:               <span class="ruby-keyword kw">end</span>&#x000A;307:             <span class="ruby-keyword kw">end</span>&#x000A;308:           <span class="ruby-keyword kw">end</span>&#x000A;309:           <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">matches</span>&#x000A;310:         <span class="ruby-keyword kw">end</span>&#x000A;311:         <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot; &gt; &quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">second</span>.<span class="ruby-identifier">to_s</span>&#x000A;312:       <span class="ruby-comment cmt"># Descendant selector: create a dependency into second selector that</span>&#x000A;313:       <span class="ruby-comment cmt"># will match all descendant elements of this one. Note,</span>&#x000A;314:       <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">statement</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^\s+\S+/</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">statement</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">selector</span>&#x000A;315:         <span class="ruby-identifier">second</span> = <span class="ruby-identifier">next_selector</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>)&#x000A;316:         <span class="ruby-ivar">@depends</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span>, <span class="ruby-identifier">first</span><span class="ruby-operator">|</span>&#x000A;317:           <span class="ruby-identifier">matches</span> = []&#x000A;318:           <span class="ruby-identifier">stack</span> = <span class="ruby-identifier">element</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">reverse</span>&#x000A;319:           <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">node</span> = <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>&#x000A;320:             <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">tag?</span>&#x000A;321:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">subset</span> = <span class="ruby-identifier">second</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">first</span>)&#x000A;322:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">first</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">subset</span>.<span class="ruby-identifier">empty?</span>&#x000A;323:                 <span class="ruby-identifier">matches</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">subset</span>.<span class="ruby-identifier">first</span>&#x000A;324:                 <span class="ruby-keyword kw">break</span>&#x000A;325:               <span class="ruby-keyword kw">else</span>&#x000A;326:                 <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">subset</span>&#x000A;327:               <span class="ruby-keyword kw">end</span>&#x000A;328:             <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">children</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">children</span>&#x000A;329:               <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">children</span>.<span class="ruby-identifier">reverse</span>&#x000A;330:             <span class="ruby-keyword kw">end</span>&#x000A;331:           <span class="ruby-keyword kw">end</span>&#x000A;332:           <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">matches</span>&#x000A;333:         <span class="ruby-keyword kw">end</span>&#x000A;334:         <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot; &quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">second</span>.<span class="ruby-identifier">to_s</span>&#x000A;335:       <span class="ruby-keyword kw">else</span>&#x000A;336:         <span class="ruby-comment cmt"># The last selector is where we check that we parsed</span>&#x000A;337:         <span class="ruby-comment cmt"># all the parts.</span>&#x000A;338:         <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>&#x000A;339:           <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;Invalid selector: #{statement}&quot;</span>&#x000A;340:         <span class="ruby-keyword kw">end</span>&#x000A;341:       <span class="ruby-keyword kw">end</span>&#x000A;342:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <h2>Public instance methods</h2>
              <div class='method public-instance' id='method-M000345'>
                <a name='M000345'></a>
                <div class='synopsis'>
                  <span class='name'>match(element, first?) => array or nil<br /></span>
                </div>
                <div class='description'>
                  <p>
                  Matches an element against the selector.
                  </p>
                  <p>
                  For a simple selector this method returns an array with the element if the
                  element matches, nil otherwise.
                  </p>
                  <p>
                  For a complex selector (sibling and descendant) this method returns an
                  array with all matching elements, nil if no match is found.
                  </p>
                  <p>
                  Use +first_only=true+ if you are only interested in the first element.
                  </p>
                  <p>
                  For example:
                  </p>
                  <pre>if selector.match(element)&#x000A;  puts &quot;Element is a login form&quot;&#x000A;end</pre>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000345-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000345-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 363</span>&#x000A;363:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">match</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">first_only</span> = <span class="ruby-keyword kw">false</span>)&#x000A;364:       <span class="ruby-comment cmt"># Match element if no element name or element name same as element name</span>&#x000A;365:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">matched</span> = (<span class="ruby-operator">!</span><span class="ruby-ivar">@tag_name</span> <span class="ruby-operator">||</span> <span class="ruby-ivar">@tag_name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">name</span>)&#x000A;366:         <span class="ruby-comment cmt"># No match if one of the attribute matches failed</span>&#x000A;367:         <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">attr</span> <span class="ruby-keyword kw">in</span> <span class="ruby-ivar">@attributes</span>&#x000A;368:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">attr</span>[<span class="ruby-value">0</span>]] <span class="ruby-operator">!~</span> <span class="ruby-identifier">attr</span>[<span class="ruby-value">1</span>]&#x000A;369:             <span class="ruby-identifier">matched</span> = <span class="ruby-keyword kw">false</span>&#x000A;370:             <span class="ruby-keyword kw">break</span>&#x000A;371:           <span class="ruby-keyword kw">end</span>&#x000A;372:         <span class="ruby-keyword kw">end</span>&#x000A;373:       <span class="ruby-keyword kw">end</span>&#x000A;374: &#x000A;375:       <span class="ruby-comment cmt"># Pseudo class matches (nth-child, empty, etc).</span>&#x000A;376:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">matched</span>&#x000A;377:         <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">pseudo</span> <span class="ruby-keyword kw">in</span> <span class="ruby-ivar">@pseudo</span>&#x000A;378:           <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">pseudo</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">element</span>)&#x000A;379:             <span class="ruby-identifier">matched</span> = <span class="ruby-keyword kw">false</span>&#x000A;380:             <span class="ruby-keyword kw">break</span>&#x000A;381:           <span class="ruby-keyword kw">end</span>&#x000A;382:         <span class="ruby-keyword kw">end</span>&#x000A;383:       <span class="ruby-keyword kw">end</span>&#x000A;384: &#x000A;385:       <span class="ruby-comment cmt"># Negation. Same rules as above, but we fail if a match is made.</span>&#x000A;386:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">matched</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@negation</span>&#x000A;387:         <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">negation</span> <span class="ruby-keyword kw">in</span> <span class="ruby-ivar">@negation</span>&#x000A;388:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">negation</span>[<span class="ruby-identifier">:tag_name</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">name</span>&#x000A;389:             <span class="ruby-identifier">matched</span> = <span class="ruby-keyword kw">false</span>&#x000A;390:           <span class="ruby-keyword kw">else</span>&#x000A;391:             <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">attr</span> <span class="ruby-keyword kw">in</span> <span class="ruby-identifier">negation</span>[<span class="ruby-identifier">:attributes</span>]&#x000A;392:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">attr</span>[<span class="ruby-value">0</span>]] <span class="ruby-operator">=~</span> <span class="ruby-identifier">attr</span>[<span class="ruby-value">1</span>]&#x000A;393:                 <span class="ruby-identifier">matched</span> = <span class="ruby-keyword kw">false</span>&#x000A;394:                 <span class="ruby-keyword kw">break</span>&#x000A;395:               <span class="ruby-keyword kw">end</span>&#x000A;396:             <span class="ruby-keyword kw">end</span>&#x000A;397:           <span class="ruby-keyword kw">end</span>&#x000A;398:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">matched</span>&#x000A;399:             <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">pseudo</span> <span class="ruby-keyword kw">in</span> <span class="ruby-identifier">negation</span>[<span class="ruby-identifier">:pseudo</span>]&#x000A;400:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">pseudo</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">element</span>)&#x000A;401:                 <span class="ruby-identifier">matched</span> = <span class="ruby-keyword kw">false</span>&#x000A;402:                 <span class="ruby-keyword kw">break</span>&#x000A;403:               <span class="ruby-keyword kw">end</span>&#x000A;404:             <span class="ruby-keyword kw">end</span>&#x000A;405:           <span class="ruby-keyword kw">end</span>&#x000A;406:           <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">matched</span>&#x000A;407:         <span class="ruby-keyword kw">end</span>&#x000A;408:       <span class="ruby-keyword kw">end</span>&#x000A;409: &#x000A;410:       <span class="ruby-comment cmt"># If element matched but depends on another element (child,</span>&#x000A;411:       <span class="ruby-comment cmt"># sibling, etc), apply the dependent matches instead.</span>&#x000A;412:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">matched</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@depends</span>&#x000A;413:         <span class="ruby-identifier">matches</span> = <span class="ruby-ivar">@depends</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">first_only</span>)&#x000A;414:       <span class="ruby-keyword kw">else</span>&#x000A;415:         <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">matched</span> <span class="ruby-value">? </span>[<span class="ruby-identifier">element</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword kw">nil</span>&#x000A;416:       <span class="ruby-keyword kw">end</span>&#x000A;417: &#x000A;418:       <span class="ruby-comment cmt"># If this selector is part of the group, try all the alternative</span>&#x000A;419:       <span class="ruby-comment cmt"># selectors (unless first_only).</span>&#x000A;420:       <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">first_only</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">matches</span>&#x000A;421:         <span class="ruby-ivar">@alternates</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">alternate</span><span class="ruby-operator">|</span>&#x000A;422:           <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">matches</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">first_only</span>&#x000A;423:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">subset</span> = <span class="ruby-identifier">alternate</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">first_only</span>)&#x000A;424:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">matches</span>&#x000A;425:               <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">subset</span>&#x000A;426:             <span class="ruby-keyword kw">else</span>&#x000A;427:               <span class="ruby-identifier">matches</span> = <span class="ruby-identifier">subset</span>&#x000A;428:             <span class="ruby-keyword kw">end</span>&#x000A;429:           <span class="ruby-keyword kw">end</span>&#x000A;430:         <span class="ruby-keyword kw">end</span>&#x000A;431:       <span class="ruby-keyword kw">end</span>&#x000A;432: &#x000A;433:       <span class="ruby-identifier">matches</span>&#x000A;434:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-M000348'>
                <a name='M000348'></a>
                <div class='synopsis'>
                  <span class='name'>next_element</span>
                  <span class='arguments'>(element, name = nil)</span>
                </div>
                <div class='description'>
                  <p>
                  Return the next element after this one. Skips sibling text nodes.
                  </p>
                  <p>
                  With the <tt>name</tt> argument, returns the next element with that name,
                  skipping other sibling elements.
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000348-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000348-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 493</span>&#x000A;493:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">next_element</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">name</span> = <span class="ruby-keyword kw">nil</span>)&#x000A;494:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">siblings</span> = <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">children</span>&#x000A;495:         <span class="ruby-identifier">found</span> = <span class="ruby-keyword kw">false</span>&#x000A;496:         <span class="ruby-identifier">siblings</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>&#x000A;497:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">element</span>)&#x000A;498:             <span class="ruby-identifier">found</span> = <span class="ruby-keyword kw">true</span>&#x000A;499:           <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">found</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">tag?</span>&#x000A;500:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">node</span> <span class="ruby-keyword kw">if</span> (<span class="ruby-identifier">name</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>)&#x000A;501:           <span class="ruby-keyword kw">end</span>&#x000A;502:         <span class="ruby-keyword kw">end</span>&#x000A;503:       <span class="ruby-keyword kw">end</span>&#x000A;504:       <span class="ruby-keyword kw">nil</span>&#x000A;505:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-M000346'>
                <a name='M000346'></a>
                <div class='synopsis'>
                  <span class='name'>select(root) => array<br /></span>
                </div>
                <div class='description'>
                  <p>
                  Selects and returns an array with all matching elements, beginning with one
                  node and traversing through all children depth-first. Returns an empty
                  array if no match is found.
                  </p>
                  <p>
                  The root node may be any element in the document, or the document itself.
                  </p>
                  <p>
                  For example:
                  </p>
                  <pre>selector = HTML::Selector.new &quot;input[type=text]&quot;&#x000A;matches = selector.select(element)&#x000A;matches.each do |match|&#x000A;  puts &quot;Found text field with name #{match.attributes['name']}&quot;&#x000A;end</pre>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000346-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000346-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 453</span>&#x000A;453:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">select</span>(<span class="ruby-identifier">root</span>)&#x000A;454:       <span class="ruby-identifier">matches</span> = []&#x000A;455:       <span class="ruby-identifier">stack</span> = [<span class="ruby-identifier">root</span>]&#x000A;456:       <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">node</span> = <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>&#x000A;457:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">tag?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">subset</span> = <span class="ruby-identifier">match</span>(<span class="ruby-identifier">node</span>, <span class="ruby-keyword kw">false</span>)&#x000A;458:           <span class="ruby-identifier">subset</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;459:             <span class="ruby-identifier">matches</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">match</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">matches</span>.<span class="ruby-identifier">any?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span> <span class="ruby-identifier">item</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">match</span>) }&#x000A;460:           <span class="ruby-keyword kw">end</span>&#x000A;461:         <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">children</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">children</span>&#x000A;462:           <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">children</span>.<span class="ruby-identifier">reverse</span>&#x000A;463:         <span class="ruby-keyword kw">end</span>&#x000A;464:       <span class="ruby-keyword kw">end</span>&#x000A;465:       <span class="ruby-identifier">matches</span>&#x000A;466:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='method public-instance' id='method-M000347'>
                <a name='M000347'></a>
                <div class='synopsis'>
                  <span class='name'>select_first</span>
                  <span class='arguments'>(root)</span>
                </div>
                <div class='description'>
                  <p>
                  Similar to <a href="Selector.html#M000346">select</a> but returns the first
                  matching element. Returns <tt>nil</tt> if no element matches the selector.
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000347-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000347-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 471</span>&#x000A;471:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">select_first</span>(<span class="ruby-identifier">root</span>)&#x000A;472:       <span class="ruby-identifier">stack</span> = [<span class="ruby-identifier">root</span>]&#x000A;473:       <span class="ruby-keyword kw">while</span> <span class="ruby-identifier">node</span> = <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>&#x000A;474:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">tag?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">subset</span> = <span class="ruby-identifier">match</span>(<span class="ruby-identifier">node</span>, <span class="ruby-keyword kw">true</span>)&#x000A;475:           <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">subset</span>.<span class="ruby-identifier">first</span> <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">subset</span>.<span class="ruby-identifier">empty?</span>&#x000A;476:         <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">children</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">children</span>&#x000A;477:           <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">children</span>.<span class="ruby-identifier">reverse</span>&#x000A;478:         <span class="ruby-keyword kw">end</span>&#x000A;479:       <span class="ruby-keyword kw">end</span>&#x000A;480:       <span class="ruby-keyword kw">nil</span>&#x000A;481:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <h2>Protected instance methods</h2>
              <div class='method protected-instance' id='method-M000350'>
                <a name='M000350'></a>
                <div class='synopsis'>
                  <span class='name'>attribute_match</span>
                  <span class='arguments'>(equality, value)</span>
                </div>
                <div class='description'>
                  <p>
                  Create a regular expression to match an attribute value based on the
                  equality operator (=, ^=, |=, etc).
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000350-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000350-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 687</span>&#x000A;687:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">attribute_match</span>(<span class="ruby-identifier">equality</span>, <span class="ruby-identifier">value</span>)&#x000A;688:       <span class="ruby-identifier">regexp</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Regexp</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">:</span> <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">escape</span>(<span class="ruby-identifier">value</span>.<span class="ruby-identifier">to_s</span>)&#x000A;689:       <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">equality</span>&#x000A;690:         <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;=&quot;</span> <span class="ruby-keyword kw">then</span>&#x000A;691:           <span class="ruby-comment cmt"># Match the attribute value in full</span>&#x000A;692:           <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;^#{regexp}$&quot;</span>)&#x000A;693:         <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;~=&quot;</span> <span class="ruby-keyword kw">then</span>&#x000A;694:           <span class="ruby-comment cmt"># Match a space-separated word within the attribute value</span>&#x000A;695:           <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;(^|\s)#{regexp}($|\s)&quot;</span>)&#x000A;696:         <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;^=&quot;</span>&#x000A;697:           <span class="ruby-comment cmt"># Match the beginning of the attribute value</span>&#x000A;698:           <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;^#{regexp}&quot;</span>)&#x000A;699:         <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;$=&quot;</span>&#x000A;700:           <span class="ruby-comment cmt"># Match the end of the attribute value</span>&#x000A;701:           <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;#{regexp}$&quot;</span>)&#x000A;702:         <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;*=&quot;</span>&#x000A;703:           <span class="ruby-comment cmt"># Match substring of the attribute value</span>&#x000A;704:           <span class="ruby-identifier">regexp</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Regexp</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">regexp</span> <span class="ruby-operator">:</span> <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">regexp</span>)&#x000A;705:         <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;|=&quot;</span> <span class="ruby-keyword kw">then</span>&#x000A;706:           <span class="ruby-comment cmt"># Match the first space-separated item of the attribute value</span>&#x000A;707:           <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;^#{regexp}($|\s)&quot;</span>)&#x000A;708:         <span class="ruby-keyword kw">else</span>&#x000A;709:           <span class="ruby-identifier">raise</span> <span class="ruby-constant">InvalidSelectorError</span>, <span class="ruby-value str">&quot;Invalid operation/value&quot;</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">empty?</span>&#x000A;710:           <span class="ruby-comment cmt"># Match all attributes values (existence check)</span>&#x000A;711:           <span class="ruby-regexp re">//</span>&#x000A;712:       <span class="ruby-keyword kw">end</span>&#x000A;713:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='method protected-instance' id='method-M000353'>
                <a name='M000353'></a>
                <div class='synopsis'>
                  <span class='name'>next_selector</span>
                  <span class='arguments'>(statement, values)</span>
                </div>
                <div class='description'>
                  <p>
                  Called to create a dependent selector (sibling, descendant, etc). Passes
                  the remainder of the statement that will be reduced to zero eventually, and
                  array of substitution values.
                  </p>
                  <p>
                  This method is called from four places, so it helps to put it here for
                  reuse. The only logic deals with the need to detect comma separators
                  (alternate) and apply them to the selector group of the top selector.
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000353-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000353-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 800</span>&#x000A;800:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">next_selector</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>)&#x000A;801:       <span class="ruby-identifier">second</span> = <span class="ruby-constant">Selector</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>)&#x000A;802:       <span class="ruby-comment cmt"># If there are alternate selectors, we group them in the top selector.</span>&#x000A;803:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">alternates</span> = <span class="ruby-identifier">second</span>.<span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-identifier">:@alternates</span>)&#x000A;804:         <span class="ruby-identifier">second</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-identifier">:@alternates</span>, [])&#x000A;805:         <span class="ruby-ivar">@alternates</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">alternates</span>&#x000A;806:       <span class="ruby-keyword kw">end</span>&#x000A;807:       <span class="ruby-identifier">second</span>&#x000A;808:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='method protected-instance' id='method-M000351'>
                <a name='M000351'></a>
                <div class='synopsis'>
                  <span class='name'>nth_child</span>
                  <span class='arguments'>(a, b, of_type, reverse)</span>
                </div>
                <div class='description'>
                  <p>
                  Returns a lambda that can match an element against the nth-child pseudo
                  class, given the following arguments:
                  </p>
                  <ul>
                  <li><tt>a</tt> &#8212; Value of a part.
                  
                  </li>
                  <li><tt>b</tt> &#8212; Value of b part.
                  
                  </li>
                  <li><tt>of_type</tt> &#8212; True to test only elements of this type (of-type).
                  
                  </li>
                  <li><tt>reverse</tt> &#8212; True to count in reverse order (last-).
                  
                  </li>
                  </ul>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000351-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000351-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 722</span>&#x000A;722:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">nth_child</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>, <span class="ruby-identifier">of_type</span>, <span class="ruby-identifier">reverse</span>)&#x000A;723:       <span class="ruby-comment cmt"># a = 0 means select at index b, if b = 0 nothing selected</span>&#x000A;724:       <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">lambda</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-keyword kw">false</span> } <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>&#x000A;725:       <span class="ruby-comment cmt"># a &lt; 0 and b &lt; 0 will never match against an index</span>&#x000A;726:       <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">lambda</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span> <span class="ruby-keyword kw">false</span> } <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>&#x000A;727:       <span class="ruby-identifier">b</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>   <span class="ruby-comment cmt"># b &lt; 0 just picks last element from each group</span>&#x000A;728:       <span class="ruby-identifier">b</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>  <span class="ruby-comment cmt"># b == 0 is same as b == 1, otherwise zero based</span>&#x000A;729:       <span class="ruby-identifier">lambda</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>&#x000A;730:         <span class="ruby-comment cmt"># Element must be inside parent element.</span>&#x000A;731:         <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">false</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">tag?</span>&#x000A;732:         <span class="ruby-identifier">index</span> = <span class="ruby-value">0</span>&#x000A;733:         <span class="ruby-comment cmt"># Get siblings, reverse if counting from last.</span>&#x000A;734:         <span class="ruby-identifier">siblings</span> = <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">children</span>&#x000A;735:         <span class="ruby-identifier">siblings</span> = <span class="ruby-identifier">siblings</span>.<span class="ruby-identifier">reverse</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">reverse</span>&#x000A;736:         <span class="ruby-comment cmt"># Match element name if of-type, otherwise ignore name.</span>&#x000A;737:         <span class="ruby-identifier">name</span> = <span class="ruby-identifier">of_type</span> <span class="ruby-value">? </span><span class="ruby-identifier">element</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">:</span> <span class="ruby-keyword kw">nil</span>&#x000A;738:         <span class="ruby-identifier">found</span> = <span class="ruby-keyword kw">false</span>&#x000A;739:         <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">child</span> <span class="ruby-keyword kw">in</span> <span class="ruby-identifier">siblings</span>&#x000A;740:           <span class="ruby-comment cmt"># Skip text nodes/comments.</span>&#x000A;741:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">tag?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-keyword kw">nil</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>)&#x000A;742:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>&#x000A;743:               <span class="ruby-comment cmt"># Shortcut when a == 0 no need to go past count</span>&#x000A;744:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">b</span>&#x000A;745:                 <span class="ruby-identifier">found</span> = <span class="ruby-identifier">child</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">element</span>)&#x000A;746:                 <span class="ruby-keyword kw">break</span>&#x000A;747:               <span class="ruby-keyword kw">end</span>&#x000A;748:             <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>&#x000A;749:               <span class="ruby-comment cmt"># Only look for first b elements</span>&#x000A;750:               <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">b</span>&#x000A;751:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">element</span>)&#x000A;752:                 <span class="ruby-identifier">found</span> = (<span class="ruby-identifier">index</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">a</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span>&#x000A;753:                 <span class="ruby-keyword kw">break</span>&#x000A;754:               <span class="ruby-keyword kw">end</span>&#x000A;755:             <span class="ruby-keyword kw">else</span>&#x000A;756:               <span class="ruby-comment cmt"># Otherwise, break if child found and count ==  an+b</span>&#x000A;757:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">element</span>)&#x000A;758:                 <span class="ruby-identifier">found</span> = (<span class="ruby-identifier">index</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">a</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">b</span>&#x000A;759:                 <span class="ruby-keyword kw">break</span>&#x000A;760:               <span class="ruby-keyword kw">end</span>&#x000A;761:             <span class="ruby-keyword kw">end</span>&#x000A;762:             <span class="ruby-identifier">index</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>&#x000A;763:           <span class="ruby-keyword kw">end</span>&#x000A;764:         <span class="ruby-keyword kw">end</span>&#x000A;765:         <span class="ruby-identifier">found</span>&#x000A;766:       <span class="ruby-keyword kw">end</span>&#x000A;767:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='method protected-instance' id='method-M000352'>
                <a name='M000352'></a>
                <div class='synopsis'>
                  <span class='name'>only_child</span>
                  <span class='arguments'>(of_type)</span>
                </div>
                <div class='description'>
                  <p>
                  Creates a only child lambda. Pass <tt>of-type</tt> to only look at elements
                  of its type.
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000352-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000352-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 772</span>&#x000A;772:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">only_child</span>(<span class="ruby-identifier">of_type</span>)&#x000A;773:       <span class="ruby-identifier">lambda</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>&#x000A;774:         <span class="ruby-comment cmt"># Element must be inside parent element.</span>&#x000A;775:         <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">false</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">tag?</span>&#x000A;776:         <span class="ruby-identifier">name</span> = <span class="ruby-identifier">of_type</span> <span class="ruby-value">? </span><span class="ruby-identifier">element</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">:</span> <span class="ruby-keyword kw">nil</span>&#x000A;777:         <span class="ruby-identifier">other</span> = <span class="ruby-keyword kw">false</span>&#x000A;778:         <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">child</span> <span class="ruby-keyword kw">in</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">children</span>&#x000A;779:           <span class="ruby-comment cmt"># Skip text nodes/comments.</span>&#x000A;780:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">tag?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-keyword kw">nil</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">name</span>)&#x000A;781:             <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">element</span>)&#x000A;782:               <span class="ruby-identifier">other</span> = <span class="ruby-keyword kw">true</span>&#x000A;783:               <span class="ruby-keyword kw">break</span>&#x000A;784:             <span class="ruby-keyword kw">end</span>&#x000A;785:           <span class="ruby-keyword kw">end</span>&#x000A;786:         <span class="ruby-keyword kw">end</span>&#x000A;787:         <span class="ruby-operator">!</span><span class="ruby-identifier">other</span>&#x000A;788:       <span class="ruby-keyword kw">end</span>&#x000A;789:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
              <div class='method protected-instance' id='method-M000349'>
                <a name='M000349'></a>
                <div class='synopsis'>
                  <span class='name'>simple_selector</span>
                  <span class='arguments'>(statement, values, can_negate = true)</span>
                </div>
                <div class='description'>
                  <p>
                  Creates a simple selector given the statement and array of substitution
                  values.
                  </p>
                  <p>
                  Returns a hash with the values <tt>tag_name</tt>, <tt>attributes</tt>,
                  <tt>pseudo</tt> (classes) and <tt>negation</tt>.
                  </p>
                  <p>
                  Called the first time with <tt>can_negate</tt> true to allow negation.
                  Called a second time with false since negation cannot be negated.
                  </p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('M000349-source'); return false">
                    [show source]
                  </a>
                  <pre id='M000349-source'>     <span class="ruby-comment cmt"># File vendor/rails/actionpack/lib/action_controller/vendor/html-scanner/html/selector.rb, line 520</span>&#x000A;520:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">simple_selector</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>, <span class="ruby-identifier">can_negate</span> = <span class="ruby-keyword kw">true</span>)&#x000A;521:       <span class="ruby-identifier">tag_name</span> = <span class="ruby-keyword kw">nil</span>&#x000A;522:       <span class="ruby-identifier">attributes</span> = []&#x000A;523:       <span class="ruby-identifier">pseudo</span> = []&#x000A;524:       <span class="ruby-identifier">negation</span> = []&#x000A;525: &#x000A;526:       <span class="ruby-comment cmt"># Element name. (Note that in negation, this can come at</span>&#x000A;527:       <span class="ruby-comment cmt"># any order, but for simplicity we allow if only first).</span>&#x000A;528:       <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^(\*|[[:alpha:]][\w\-]*)/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;529:         <span class="ruby-identifier">match</span>.<span class="ruby-identifier">strip!</span>&#x000A;530:         <span class="ruby-identifier">tag_name</span> = <span class="ruby-identifier">match</span>.<span class="ruby-identifier">downcase</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">match</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;*&quot;</span>&#x000A;531:         <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">match</span>&#x000A;532:         <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;533:       <span class="ruby-keyword kw">end</span>&#x000A;534: &#x000A;535:       <span class="ruby-comment cmt"># Get identifier, class, attribute name, pseudo or negation.</span>&#x000A;536:       <span class="ruby-keyword kw">while</span> <span class="ruby-keyword kw">true</span>&#x000A;537:         <span class="ruby-comment cmt"># Element identifier.</span>&#x000A;538:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^#(\?|[\w\-]+)/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;539:           <span class="ruby-identifier">id</span> = <span class="ruby-identifier">$1</span>&#x000A;540:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">id</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;?&quot;</span>&#x000A;541:             <span class="ruby-identifier">id</span> = <span class="ruby-identifier">values</span>.<span class="ruby-identifier">shift</span>&#x000A;542:           <span class="ruby-keyword kw">end</span>&#x000A;543:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;##{id}&quot;</span>&#x000A;544:           <span class="ruby-identifier">id</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;^#{Regexp.escape(id.to_s)}$&quot;</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">id</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Regexp</span>)&#x000A;545:           <span class="ruby-identifier">attributes</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-value str">&quot;id&quot;</span>, <span class="ruby-identifier">id</span>]&#x000A;546:           <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;547:         <span class="ruby-keyword kw">end</span>&#x000A;548: &#x000A;549:         <span class="ruby-comment cmt"># Class name.</span>&#x000A;550:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^\.([\w\-]+)/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;551:           <span class="ruby-identifier">class_name</span> = <span class="ruby-identifier">$1</span>&#x000A;552:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;.#{class_name}&quot;</span>&#x000A;553:           <span class="ruby-identifier">class_name</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;(^|\s)#{Regexp.escape(class_name)}($|\s)&quot;</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">class_name</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Regexp</span>)&#x000A;554:           <span class="ruby-identifier">attributes</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-value str">&quot;class&quot;</span>, <span class="ruby-identifier">class_name</span>]&#x000A;555:           <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;556:         <span class="ruby-keyword kw">end</span>&#x000A;557: &#x000A;558:         <span class="ruby-comment cmt"># Attribute value.</span>&#x000A;559:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^\[\s*([[:alpha:]][\w\-:]*)\s*((?:[~|^$*])?=)?\s*('[^']*'|&quot;[^*]&quot;|[^\]]*)\s*\]/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;560:           <span class="ruby-identifier">name</span>, <span class="ruby-identifier">equality</span>, <span class="ruby-identifier">value</span> = <span class="ruby-identifier">$1</span>, <span class="ruby-identifier">$2</span>, <span class="ruby-identifier">$3</span>&#x000A;561:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;?&quot;</span>&#x000A;562:             <span class="ruby-identifier">value</span> = <span class="ruby-identifier">values</span>.<span class="ruby-identifier">shift</span>&#x000A;563:           <span class="ruby-keyword kw">else</span>&#x000A;564:             <span class="ruby-comment cmt"># Handle single and double quotes.</span>&#x000A;565:             <span class="ruby-identifier">value</span>.<span class="ruby-identifier">strip!</span>&#x000A;566:             <span class="ruby-keyword kw">if</span> (<span class="ruby-identifier">value</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?&quot;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">value</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">value</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">value</span>[<span class="ruby-value">-1</span>]&#x000A;567:               <span class="ruby-identifier">value</span> = <span class="ruby-identifier">value</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>]&#x000A;568:             <span class="ruby-keyword kw">end</span>&#x000A;569:           <span class="ruby-keyword kw">end</span>&#x000A;570:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;[#{name}#{equality}'#{value}']&quot;</span>&#x000A;571:           <span class="ruby-identifier">attributes</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-identifier">name</span>.<span class="ruby-identifier">downcase</span>.<span class="ruby-identifier">strip</span>, <span class="ruby-identifier">attribute_match</span>(<span class="ruby-identifier">equality</span>, <span class="ruby-identifier">value</span>)]&#x000A;572:           <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;573:         <span class="ruby-keyword kw">end</span>&#x000A;574: &#x000A;575:         <span class="ruby-comment cmt"># Root element only.</span>&#x000A;576:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^:root/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;577:           <span class="ruby-identifier">pseudo</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">lambda</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>&#x000A;578:             <span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">element</span>.<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">tag?</span>&#x000A;579:           <span class="ruby-keyword kw">end</span>&#x000A;580:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot;:root&quot;</span>&#x000A;581:           <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;582:         <span class="ruby-keyword kw">end</span>&#x000A;583: &#x000A;584:         <span class="ruby-comment cmt"># Nth-child including last and of-type.</span>&#x000A;585:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^:nth-(last-)?(child|of-type)\((odd|even|(\d+|\?)|(-?\d*|\?)?n([+\-]\d+|\?)?)\)/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;586:           <span class="ruby-identifier">reverse</span> = <span class="ruby-identifier">$1</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;last-&quot;</span>&#x000A;587:           <span class="ruby-identifier">of_type</span> = <span class="ruby-identifier">$2</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;of-type&quot;</span>&#x000A;588:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;:nth-#{$1}#{$2}(&quot;</span>&#x000A;589:           <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">$3</span>&#x000A;590:             <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;odd&quot;</span>&#x000A;591:               <span class="ruby-identifier">pseudo</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">nth_child</span>(<span class="ruby-value">2</span>, <span class="ruby-value">1</span>, <span class="ruby-identifier">of_type</span>, <span class="ruby-identifier">reverse</span>)&#x000A;592:               <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot;odd)&quot;</span>&#x000A;593:             <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;even&quot;</span>&#x000A;594:               <span class="ruby-identifier">pseudo</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">nth_child</span>(<span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-identifier">of_type</span>, <span class="ruby-identifier">reverse</span>)&#x000A;595:               <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot;even)&quot;</span>&#x000A;596:             <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^(\d+|\?)$/</span>  <span class="ruby-comment cmt"># b only</span>&#x000A;597:               <span class="ruby-identifier">b</span> = (<span class="ruby-identifier">$1</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;?&quot;</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">$1</span>).<span class="ruby-identifier">to_i</span>&#x000A;598:               <span class="ruby-identifier">pseudo</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">nth_child</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">b</span>, <span class="ruby-identifier">of_type</span>, <span class="ruby-identifier">reverse</span>)&#x000A;599:               <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;#{b})&quot;</span>&#x000A;600:             <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^(-?\d*|\?)?n([+\-]\d+|\?)?$/</span>&#x000A;601:               <span class="ruby-identifier">a</span> = (<span class="ruby-identifier">$1</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;?&quot;</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">:</span>&#x000A;602:                    <span class="ruby-identifier">$1</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-operator">?</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">$1</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;-&quot;</span> <span class="ruby-operator">?</span> <span class="ruby-value">-1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">$1</span>).<span class="ruby-identifier">to_i</span>&#x000A;603:               <span class="ruby-identifier">b</span> = (<span class="ruby-identifier">$2</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;?&quot;</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">$2</span>).<span class="ruby-identifier">to_i</span>&#x000A;604:               <span class="ruby-identifier">pseudo</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">nth_child</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>, <span class="ruby-identifier">of_type</span>, <span class="ruby-identifier">reverse</span>)&#x000A;605:               <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">b</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-node">&quot;#{a}n+#{b})&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-node">&quot;#{a}n#{b})&quot;</span>)&#x000A;606:             <span class="ruby-keyword kw">else</span>&#x000A;607:               <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;Invalid nth-child #{match}&quot;</span>&#x000A;608:           <span class="ruby-keyword kw">end</span>&#x000A;609:           <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;610:         <span class="ruby-keyword kw">end</span>&#x000A;611:         <span class="ruby-comment cmt"># First/last child (of type).</span>&#x000A;612:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^:(first|last)-(child|of-type)/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;613:           <span class="ruby-identifier">reverse</span> = <span class="ruby-identifier">$1</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;last&quot;</span>&#x000A;614:           <span class="ruby-identifier">of_type</span> = <span class="ruby-identifier">$2</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;of-type&quot;</span>&#x000A;615:           <span class="ruby-identifier">pseudo</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">nth_child</span>(<span class="ruby-value">0</span>, <span class="ruby-value">1</span>, <span class="ruby-identifier">of_type</span>, <span class="ruby-identifier">reverse</span>)&#x000A;616:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;:#{$1}-#{$2}&quot;</span>&#x000A;617:           <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;618:         <span class="ruby-keyword kw">end</span>&#x000A;619:         <span class="ruby-comment cmt"># Only child (of type).</span>&#x000A;620:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^:only-(child|of-type)/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;621:           <span class="ruby-identifier">of_type</span> = <span class="ruby-identifier">$1</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;of-type&quot;</span>&#x000A;622:           <span class="ruby-identifier">pseudo</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">only_child</span>(<span class="ruby-identifier">of_type</span>)&#x000A;623:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;:only-#{$1}&quot;</span>&#x000A;624:           <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;625:         <span class="ruby-keyword kw">end</span>&#x000A;626: &#x000A;627:         <span class="ruby-comment cmt"># Empty: no child elements or meaningful content (whitespaces</span>&#x000A;628:         <span class="ruby-comment cmt"># are ignored).</span>&#x000A;629:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^:empty/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;630:           <span class="ruby-identifier">pseudo</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">lambda</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>&#x000A;631:             <span class="ruby-identifier">empty</span> = <span class="ruby-keyword kw">true</span>&#x000A;632:             <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">child</span> <span class="ruby-keyword kw">in</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">children</span>&#x000A;633:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">tag?</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">child</span>.<span class="ruby-identifier">content</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>&#x000A;634:                 <span class="ruby-identifier">empty</span> = <span class="ruby-keyword kw">false</span>&#x000A;635:                 <span class="ruby-keyword kw">break</span>&#x000A;636:               <span class="ruby-keyword kw">end</span>&#x000A;637:             <span class="ruby-keyword kw">end</span>&#x000A;638:             <span class="ruby-identifier">empty</span>&#x000A;639:           <span class="ruby-keyword kw">end</span>&#x000A;640:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot;:empty&quot;</span>&#x000A;641:           <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;642:         <span class="ruby-keyword kw">end</span>&#x000A;643:         <span class="ruby-comment cmt"># Content: match the text content of the element, stripping</span>&#x000A;644:         <span class="ruby-comment cmt"># leading and trailing spaces.</span>&#x000A;645:         <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^:content\(\s*(\?|'[^']*'|&quot;[^&quot;]*&quot;|[^)]*)\s*\)/</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>&#x000A;646:           <span class="ruby-identifier">content</span> = <span class="ruby-identifier">$1</span>&#x000A;647:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">content</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;?&quot;</span>&#x000A;648:             <span class="ruby-identifier">content</span> = <span class="ruby-identifier">values</span>.<span class="ruby-identifier">shift</span>&#x000A;649:           <span class="ruby-keyword kw">elsif</span> (<span class="ruby-identifier">content</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?&quot;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">content</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">content</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">content</span>[<span class="ruby-value">-1</span>]&#x000A;650:             <span class="ruby-identifier">content</span> = <span class="ruby-identifier">content</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-2</span>]&#x000A;651:           <span class="ruby-keyword kw">end</span>&#x000A;652:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-node">&quot;:content('#{content}')&quot;</span>&#x000A;653:           <span class="ruby-identifier">content</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;^#{Regexp.escape(content.to_s)}$&quot;</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">content</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Regexp</span>)&#x000A;654:           <span class="ruby-identifier">pseudo</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">lambda</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">element</span><span class="ruby-operator">|</span>&#x000A;655:             <span class="ruby-identifier">text</span> = <span class="ruby-value str">&quot;&quot;</span>&#x000A;656:             <span class="ruby-keyword kw">for</span> <span class="ruby-identifier">child</span> <span class="ruby-keyword kw">in</span> <span class="ruby-identifier">element</span>.<span class="ruby-identifier">children</span>&#x000A;657:               <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">tag?</span>&#x000A;658:                 <span class="ruby-identifier">text</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">content</span>&#x000A;659:               <span class="ruby-keyword kw">end</span>&#x000A;660:             <span class="ruby-keyword kw">end</span>&#x000A;661:             <span class="ruby-identifier">text</span>.<span class="ruby-identifier">strip</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">content</span>&#x000A;662:           <span class="ruby-keyword kw">end</span>&#x000A;663:           <span class="ruby-value str">&quot;&quot;</span> <span class="ruby-comment cmt"># Remove</span>&#x000A;664:         <span class="ruby-keyword kw">end</span>&#x000A;665: &#x000A;666:         <span class="ruby-comment cmt"># Negation. Create another simple selector to handle it.</span>&#x000A;667:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^:not\(\s*/</span>, <span class="ruby-value str">&quot;&quot;</span>)&#x000A;668:           <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-value str">&quot;Double negatives are not missing feature&quot;</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">can_negate</span>&#x000A;669:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot;:not(&quot;</span>&#x000A;670:           <span class="ruby-identifier">negation</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">simple_selector</span>(<span class="ruby-identifier">statement</span>, <span class="ruby-identifier">values</span>, <span class="ruby-keyword kw">false</span>)&#x000A;671:           <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-value str">&quot;Negation not closed&quot;</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">statement</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp re">/^\s*\)/</span>, <span class="ruby-value str">&quot;&quot;</span>)&#x000A;672:           <span class="ruby-ivar">@source</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot;)&quot;</span>&#x000A;673:           <span class="ruby-keyword kw">next</span>&#x000A;674:         <span class="ruby-keyword kw">end</span>&#x000A;675: &#x000A;676:         <span class="ruby-comment cmt"># No match: moving on.</span>&#x000A;677:         <span class="ruby-keyword kw">break</span>&#x000A;678:       <span class="ruby-keyword kw">end</span>&#x000A;679: &#x000A;680:       <span class="ruby-comment cmt"># Return hash. The keys are mapped to instance variables.</span>&#x000A;681:       {<span class="ruby-identifier">:tag_name=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">tag_name</span>, <span class="ruby-identifier">:attributes=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">:pseudo=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">pseudo</span>, <span class="ruby-identifier">:negation=</span><span class="ruby-operator">&gt;</span><span class="ruby-identifier">negation</span>}&#x000A;682:     <span class="ruby-keyword kw">end</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
